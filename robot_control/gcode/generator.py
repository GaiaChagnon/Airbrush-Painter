"""
G-code generator.

Converts Job IR operations to G-code strings with coordinate transforms
and Z state mapping. All coordinate transforms happen here, not at runtime.

Key principles:
    - No G92 runtime offsets - all positions are absolute machine coordinates
    - Canvas offset + tool offset applied during generation
    - Semantic Z states mapped to configured values
    - Soft-limit validation before generation
"""

from __future__ import annotations

import logging
from io import StringIO
from typing import Literal

from robot_control.configs.loader import MachineConfig
from robot_control.job_ir.operations import (
    DrawPolyline,
    HomeXY,
    LinearMove,
    Operation,
    RapidXY,
    SelectTool,
    Stroke,
    ToolDown,
    ToolUp,
)

logger = logging.getLogger(__name__)


class GCodeError(Exception):
    """Raised when G-code generation fails."""

    pass


class GCodeGenerator:
    """
    Convert Job IR operations to G-code.

    Handles coordinate transforms (canvas to machine), Z state mapping,
    and feed rate management. Validates positions against soft limits.

    Parameters
    ----------
    config : MachineConfig
        Machine configuration with work area, canvas, tools, and Z states.

    Examples
    --------
    >>> from robot_control.configs.loader import load_config
    >>> from robot_control.job_ir.operations import HomeXY, RapidXY, ToolDown, ToolUp
    >>> config = load_config()
    >>> gen = GCodeGenerator(config)
    >>> ops = [HomeXY(), RapidXY(x=10, y=20), ToolDown(), ToolUp()]
    >>> gcode = gen.generate(ops)
    """

    def __init__(self, config: MachineConfig) -> None:
        self.config = config
        self._current_tool: Literal["pen", "airbrush"] = "pen"
        self._tool_is_up: bool = True

    def generate(
        self,
        operations: list[Operation],
        *,
        validate_limits: bool = True,
        include_header: bool = True,
    ) -> str:
        """
        Generate G-code from a list of operations.

        Parameters
        ----------
        operations : list[Operation]
            Job IR operations to convert.
        validate_limits : bool
            If True, validate all positions against soft limits before generation.
        include_header : bool
            If True, include initialization header (units, absolute mode).

        Returns
        -------
        str
            Complete G-code program.

        Raises
        ------
        GCodeError
            If validation fails or an unknown operation is encountered.
        """
        if validate_limits:
            self._validate_limits(operations)

        self._current_tool = "pen"
        self._tool_is_up = True

        output = StringIO()

        if include_header:
            self._write_header(output)

        for op in operations:
            self._generate_operation(op, output)

        return output.getvalue()

    def generate_stroke(self, stroke: Stroke, *, include_barrier: bool = True) -> str:
        """
        Generate G-code for a single stroke.

        Used in interactive mode where strokes are sent one at a time.
        Optionally includes M400 barrier for motion synchronization.

        Parameters
        ----------
        stroke : Stroke
            List of operations forming a stroke.
        include_barrier : bool
            If True, append M400 to wait for motion completion.

        Returns
        -------
        str
            G-code for the stroke.
        """
        output = StringIO()

        for op in stroke:
            self._generate_operation(op, output)

        if include_barrier:
            output.write("M400 ; Wait for moves to complete\n")

        return output.getvalue()

    def _write_header(self, output: StringIO) -> None:
        """Write G-code initialization header."""
        output.write("; Generated by robot_control GCodeGenerator\n")
        output.write("G21 ; Units: millimeters\n")
        output.write("G90 ; Absolute positioning\n")
        output.write("\n")

    def _generate_operation(self, op: Operation, output: StringIO) -> None:
        """Generate G-code for a single operation."""
        if isinstance(op, HomeXY):
            output.write("G28 X Y ; Home X and Y axes\n")

        elif isinstance(op, SelectTool):
            self._current_tool = op.tool
            macro = "TOOL_PEN" if op.tool == "pen" else "TOOL_AIRBRUSH"
            output.write(f"{macro} ; Select {op.tool} tool\n")

        elif isinstance(op, ToolUp):
            z = self.config.z_states.travel_mm
            feed = self.config.get_tool(self._current_tool).plunge_feed_mm_min
            output.write(f"G0 Z{z:.3f} F{feed:.0f} ; Tool up (travel height)\n")
            self._tool_is_up = True

        elif isinstance(op, ToolDown):
            z = self.config.get_z_for_tool(self._current_tool, "work")
            feed = self.config.get_tool(self._current_tool).plunge_feed_mm_min
            output.write(f"G1 Z{z:.3f} F{feed:.0f} ; Tool down (work height)\n")
            self._tool_is_up = False

        elif isinstance(op, RapidXY):
            mx, my = self.config.canvas_to_machine(op.x, op.y, self._current_tool)
            feed = self.config.get_tool(self._current_tool).travel_feed_mm_min
            output.write(f"G0 X{mx:.3f} Y{my:.3f} F{feed:.0f} ; Rapid to ({op.x:.2f}, {op.y:.2f})\n")

        elif isinstance(op, LinearMove):
            mx, my = self.config.canvas_to_machine(op.x, op.y, self._current_tool)
            feed = op.feed or self.config.get_tool(self._current_tool).feed_mm_min
            output.write(f"G1 X{mx:.3f} Y{my:.3f} F{feed:.0f}\n")

        elif isinstance(op, DrawPolyline):
            feed = op.feed or self.config.get_tool(self._current_tool).feed_mm_min
            for i, (x, y) in enumerate(op.points):
                mx, my = self.config.canvas_to_machine(x, y, self._current_tool)
                if i == 0:
                    # First point sets feed rate
                    output.write(f"G1 X{mx:.3f} Y{my:.3f} F{feed:.0f}\n")
                else:
                    output.write(f"G1 X{mx:.3f} Y{my:.3f}\n")

        else:
            # Unknown operation - log warning but continue
            logger.warning("Unknown operation type: %s", type(op).__name__)

    def _validate_limits(self, operations: list[Operation]) -> None:
        """
        Validate all positions against soft limits.

        Raises
        ------
        GCodeError
            If any position exceeds work area or canvas bounds.
        """
        for op in operations:
            if isinstance(op, RapidXY):
                self._check_position(op.x, op.y, "RapidXY", is_drawing=False)
            elif isinstance(op, LinearMove):
                self._check_position(op.x, op.y, "LinearMove", is_drawing=True)
            elif isinstance(op, DrawPolyline):
                for i, (x, y) in enumerate(op.points):
                    self._check_position(x, y, f"DrawPolyline point {i}", is_drawing=True)

    def _check_position(
        self,
        x: float,
        y: float,
        context: str,
        is_drawing: bool,
    ) -> None:
        """
        Check if a canvas position is within valid bounds.

        Parameters
        ----------
        x : float
            Canvas X coordinate.
        y : float
            Canvas Y coordinate.
        context : str
            Description of the operation for error messages.
        is_drawing : bool
            If True, check against canvas bounds. If False, check work area.
        """
        # Convert to machine coordinates for work area check
        mx, my = self.config.canvas_to_machine(x, y, self._current_tool)

        # Check work area limits
        if mx < 0 or mx > self.config.work_area.x:
            raise GCodeError(
                f"{context}: X={x:.2f} (machine X={mx:.2f}) exceeds work area "
                f"[0, {self.config.work_area.x:.1f}]"
            )
        if my < 0 or my > self.config.work_area.y:
            raise GCodeError(
                f"{context}: Y={y:.2f} (machine Y={my:.2f}) exceeds work area "
                f"[0, {self.config.work_area.y:.1f}]"
            )

        # For drawing operations, also check canvas bounds
        if is_drawing:
            if x < 0 or x > self.config.canvas.width_mm:
                raise GCodeError(
                    f"{context}: X={x:.2f} exceeds canvas bounds "
                    f"[0, {self.config.canvas.width_mm:.1f}]"
                )
            if y < 0 or y > self.config.canvas.height_mm:
                raise GCodeError(
                    f"{context}: Y={y:.2f} exceeds canvas bounds "
                    f"[0, {self.config.canvas.height_mm:.1f}]"
                )


def generate_file(
    operations: list[Operation],
    output_path: str,
    config: MachineConfig,
) -> str:
    """
    Generate G-code and write to file.

    Convenience function for file-run mode.

    Parameters
    ----------
    operations : list[Operation]
        Job IR operations to convert.
    output_path : str
        Path to write G-code file.
    config : MachineConfig
        Machine configuration.

    Returns
    -------
    str
        Path to the generated file.
    """
    gen = GCodeGenerator(config)
    gcode = gen.generate(operations)

    with open(output_path, "w") as f:
        f.write(gcode)

    logger.info("Generated G-code: %s (%d bytes)", output_path, len(gcode))
    return output_path

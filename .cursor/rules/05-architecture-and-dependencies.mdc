---
description: Architecture & dependency direction (layering, boundaries, no cycles)
alwaysApply: true
---
# Architectural layering (strict)
- Follow a **one-way dependency flow**:
scripts/ (entrypoints)
↓
src/gui/, src/rl_agent/, src/airbrush_robot_env/, src/airbrush_simulator/, src/data_pipeline/
↓
src/utils/  (lowest layer)

- **No module outside `src/utils/` may import from a peer** in the same layer (e.g., `env` must not import `gui`, `rl_agent` must not import `env`).
- **No cyclic imports** anywhere. If a design pushes you toward cycles, extract the shared part into `src/utils/` or a new small submodule.

# Boundaries & responsibilities
- `scripts/`: thin CLIs only. Wiring, not logic.
- `gui/`: read-only observer; **must not control training loops** or mutate model state directly.
- `airbrush_simulator/`: pure rendering & physics; **no file I/O** beyond what’s passed in.
- `airbrush_robot_env/`: RL glue; no GUI, no disk writes (except through explicit callbacks).
- `data_pipeline/`: deterministic transforms; no training-time conditionals.
- `rl_agent/`: networks & policies; no disk I/O; device/precision set by config only.
- `utils/`: cross-cutting primitives; **no imports from upper layers**.

# Side-effects & purity
- Default to **pure functions**. If a function reads/writes files or mutates global state,
its name and docstring must explicitly state it (e.g., `*_inplace`, `*_to_file`).
- No hidden network, GPU, or filesystem side-effects in functions that look pure.

# External libraries
- Non-trivial or vendor APIs (OpenCV, LPIPS, nvdiffrast, Potrace) are **wrapped** behind our code.
Callers depend on our wrapper **not** the vendor API directly.
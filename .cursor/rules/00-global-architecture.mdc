---
description: Global architecture invariants for Hybrid AI Painter (v2.3)
alwaysApply: true
---
# Do not violate these invariants

- **Multi-resolution triad** is mandatory:
  - render_px = physics grid, reward_px = LPIPS grid, obs_px = policy input.
  - During training: keep `reward_px == render_px` unless a test explicitly overrides.
- **Geometry = millimeters** end-to-end. Convert mm↔px **only** at renderer/env boundaries via `src.utils.compute.{mm_to_px, px_to_mm}`. Do not hand-roll conversions.
- **Fixed stroke cap** (e.g., 1500). The environment must terminate at the cap; there are no time/ink penalties in reward.
- **Reward = LPIPS improvement only.** Always normalize images to **[-1, 1]** and compute LPIPS in **FP32** (no autocast). Use `compute.normalize_img_for_lpips`.
- **Open-loop** pipeline (no camera during painting).
- **YAML‑only** configs and manifests. **No JSON** anywhere. Validation must go through `src.utils.validators`.
- **DGX Spark defaults:** prefer **BF16** + **channels-last** for networks; LUT tensors remain **FP32**.
- **Decoupled GUI** reads artifacts written **atomically** by training. Use `src.utils.io.atomic_*` and `symlink_atomic`.
- **Adversarial tests**: keep negative tests for reward hacking; do not weaken them.
- **Containerized** execution only; avoid system-specific hacks.